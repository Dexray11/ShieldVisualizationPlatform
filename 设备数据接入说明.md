盾构掘进参数数据接入说明

 一、当前数据说明

1.1 示例数据确认
示例数据位置：`src/database/DatabaseManager.cpp` 第724-770行的 `insertDefaultData()` 函数中

示例数据包含：
- 10条掘进参数记录
- 时间范围：2024-12-03 09:50:00 开始，每5分钟一条
- 桩号范围：K3+086.00 到 K3+086.45
- 参数示例：
  - 土仓土压力：0.25-0.29 MPa
  - 推力：2500-2700 kN
  - 刀盘转速：1.5 rpm
  - 刀盘扭矩：2000-2300 kN·m

### 1.2 数据库表结构

```sql
CREATE TABLE excavation_parameters (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    project_id INTEGER NOT NULL,
    excavation_time DATETIME,           -- 掘进时间
    stake_mark VARCHAR(50),             -- 桩号（如：K3+086.00）
    mileage REAL,                       -- 里程（米）
    excavation_mode VARCHAR(50),        -- 掘进模式（如：土压平衡）
    chamber_pressure REAL,              -- 土仓土压力（MPa）
    thrust_force REAL,                  -- 千斤顶推力（kN）
    cutter_speed REAL,                  -- 刀盘转速（rpm）
    cutter_torque REAL,                 -- 刀盘扭矩（kN·m）
    excavation_speed REAL,              -- 掘进速度（mm/min）
    grouting_pressure REAL,             -- 注浆压力（MPa）
    grouting_volume REAL,               -- 注浆量（m³）
    segment_number VARCHAR(50),         -- 管片编号
    excavation_duration INTEGER,        -- 掘进时长（分钟）
    idle_duration INTEGER,              -- 闲置时长（分钟）
    fault_duration INTEGER,             -- 故障时长（分钟）
    excavation_distance REAL,           -- 掘进距离（米）
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (project_id) REFERENCES projects(project_id)
);
```

---

二、数据接入方案

根据盾构设备的不同数据输出方式，我们提供以下几种数据接入方案：

方案1：CSV文件导入（推荐用于历史数据）

  适用场景
- 盾构设备定期生成CSV文件
- 需要批量导入历史数据
- 离线数据整理

CSV文件格式要求

csv
掘进时间,桩号,里程,掘进模式,土仓土压力,推力,刀盘转速,刀盘扭矩,掘进速度,注浆压力,注浆量,管片编号,掘进时长,闲置时长,故障时长,掘进距离
2024-12-03 09:50:00,K3+086.00,3086.00,土压平衡,0.25,2500.0,1.5,2000.0,50.0,2.5,6.0,SG-3000,5,0,0,0.05
2024-12-03 09:55:00,K3+086.05,3086.05,土压平衡,0.27,2550.0,1.5,2100.0,50.0,2.5,6.0,SG-3001,5,0,0,0.05

注意事项：
1. 第一行为表头（必须）
2. 时间格式：`YYYY-MM-DD HH:MM:SS`
3. 数值字段不要包含单位（如：直接写2500.0，不要写"2500.0 kN"）
4. 确保CSV文件使用UTF-8编码

实现代码示例

在项目管理界面添加"导入CSV"按钮，调用以下代码：

cpp
在 ProjectManagementWindow.cpp 中添加
void ProjectManagementWindow::onImportExcavationCSV()
{
    QString fileName = QFileDialog::getOpenFileName(
        this, "选择掘进参数CSV文件", "", "CSV文件 (*.csv)");
    
    if (fileName.isEmpty()) {
        return;
    }
    
    QFile file(fileName);
    if (!file.open(QIODevice::ReadOnly | QIODevice::Text)) {
        QMessageBox::critical(this, "错误", "无法打开文件！");
        return;
    }
    
    QTextStream in(&file);
    in.setEncoding(QStringConverter::Utf8);
    
    // 跳过表头
    QString header = in.readLine();
    
    QList<ExcavationParameter> params;
    int lineNum = 1;
    int successCount = 0;
    int errorCount = 0;
    
    while (!in.atEnd()) {
        lineNum++;
        QString line = in.readLine();
        QStringList fields = line.split(',');
        
        if (fields.size() < 16) {
            qWarning() << "第" << lineNum << "行数据不完整，已跳过";
            errorCount++;
            continue;
        }
        
        try {
            ExcavationParameter param;
            param.setProjectId(currentProjectId);  // 设置当前项目ID
            param.setExcavationTime(QDateTime::fromString(fields[0].trimmed(), "yyyy-MM-dd HH:mm:ss"));
            param.setStakeMark(fields[1].trimmed());
            param.setMileage(fields[2].trimmed().toDouble());
            param.setExcavationMode(fields[3].trimmed());
            param.setChamberPressure(fields[4].trimmed().toDouble());
            param.setThrustForce(fields[5].trimmed().toDouble());
            param.setCutterSpeed(fields[6].trimmed().toDouble());
            param.setCutterTorque(fields[7].trimmed().toDouble());
            param.setExcavationSpeed(fields[8].trimmed().toDouble());
            param.setGroutingPressure(fields[9].trimmed().toDouble());
            param.setGroutingVolume(fields[10].trimmed().toDouble());
            param.setSegmentNumber(fields[11].trimmed());
            param.setExcavationDuration(fields[12].trimmed().toInt());
            param.setIdleDuration(fields[13].trimmed().toInt());
            param.setFaultDuration(fields[14].trimmed().toInt());
            param.setExcavationDistance(fields[15].trimmed().toDouble());
            
            params.append(param);
            successCount++;
            
        } catch (...) {
            qWarning() << "第" << lineNum << "行数据格式错误，已跳过";
            errorCount++;
        }
    }
    
    file.close();
    
    // 批量插入数据库
    ExcavationParameterDAO dao;
    if (dao.batchInsertExcavationParameters(params)) {
        QMessageBox::information(this, "导入成功", 
            QString("成功导入 %1 条记录\n失败 %2 条记录").arg(successCount).arg(errorCount));
        loadExcavationData();  // 刷新界面
    } else {
        QMessageBox::critical(this, "导入失败", "数据库写入失败：" + dao.getLastError());
    }
}
```

---

方案2：TCP/IP网络接口（推荐用于实时数据）

#### 适用场景
- 盾构设备通过网络实时发送数据
- 需要实时监控掘进参数
- 设备支持TCP或UDP协议

#### 网络协议设计

**方式A：JSON格式（推荐）**

设备发送JSON数据包：
```json
{
    "timestamp": "2024-12-03 10:00:00",
    "stake_mark": "K3+086.50",
    "mileage": 3086.50,
    "excavation_mode": "土压平衡",
    "chamber_pressure": 0.28,
    "thrust_force": 2600.0,
    "cutter_speed": 1.5,
    "cutter_torque": 2150.0,
    "excavation_speed": 50.0,
    "grouting_pressure": 2.5,
    "grouting_volume": 6.0,
    "segment_number": "SG-3010",
    "excavation_duration": 5,
    "idle_duration": 0,
    "fault_duration": 0,
    "excavation_distance": 0.05
}
```

**方式B：固定格式字符串**

格式：`时间|桩号|里程|...|掘进距离\n`

示例：
```
2024-12-03 10:00:00|K3+086.50|3086.50|土压平衡|0.28|2600.0|1.5|2150.0|50.0|2.5|6.0|SG-3010|5|0|0|0.05
```

#### 实现代码示例（TCP客户端）

创建新类 `ExcavationDataReceiver.h`：

```cpp
#ifndef EXCAVATIONDATARECEIVER_H
#define EXCAVATIONDATARECEIVER_H

#include <QObject>
#include <QTcpSocket>
#include <QTimer>
#include <QJsonDocument>
#include <QJsonObject>
#include "src/models/ExcavationParameter.h"

class ExcavationDataReceiver : public QObject
{
    Q_OBJECT

public:
    explicit ExcavationDataReceiver(QObject *parent = nullptr);
    ~ExcavationDataReceiver();
    
    // 连接到设备
    void connectToDevice(const QString &host, quint16 port);
    
    // 断开连接
    void disconnect();
    
    // 设置项目ID
    void setProjectId(int projectId) { m_projectId = projectId; }
    
    // 检查连接状态
    bool isConnected() const;

signals:
    // 接收到新数据
    void newDataReceived(const ExcavationParameter &param);
    
    // 连接状态变化
    void connectionStateChanged(bool connected);
    
    // 错误信号
    void errorOccurred(const QString &error);

private slots:
    void onConnected();
    void onDisconnected();
    void onReadyRead();
    void onError(QAbstractSocket::SocketError error);
    void onReconnectTimeout();

private:
    void parseJsonData(const QByteArray &data);
    void parseFixedFormatData(const QString &line);
    void saveToDatabase(const ExcavationParameter &param);

private:
    QTcpSocket *m_socket;
    QTimer *m_reconnectTimer;
    QString m_host;
    quint16 m_port;
    int m_projectId;
    QByteArray m_buffer;  // 数据缓冲区
};

#endif // EXCAVATIONDATARECEIVER_H
```

`ExcavationDataReceiver.cpp` 实现：

```cpp
#include "ExcavationDataReceiver.h"
#include "src/database/ExcavationParameterDAO.h"
#include <QDebug>

ExcavationDataReceiver::ExcavationDataReceiver(QObject *parent)
    : QObject(parent)
    , m_socket(new QTcpSocket(this))
    , m_reconnectTimer(new QTimer(this))
    , m_projectId(0)
{
    connect(m_socket, &QTcpSocket::connected, this, &ExcavationDataReceiver::onConnected);
    connect(m_socket, &QTcpSocket::disconnected, this, &ExcavationDataReceiver::onDisconnected);
    connect(m_socket, &QTcpSocket::readyRead, this, &ExcavationDataReceiver::onReadyRead);
    connect(m_socket, &QTcpSocket::errorOccurred, this, &ExcavationDataReceiver::onError);
    
    m_reconnectTimer->setInterval(5000);  // 5秒重连一次
    connect(m_reconnectTimer, &QTimer::timeout, this, &ExcavationDataReceiver::onReconnectTimeout);
}

ExcavationDataReceiver::~ExcavationDataReceiver()
{
    m_socket->disconnectFromHost();
}

void ExcavationDataReceiver::connectToDevice(const QString &host, quint16 port)
{
    m_host = host;
    m_port = port;
    
    qDebug() << "正在连接到设备：" << host << ":" << port;
    m_socket->connectToHost(host, port);
}

void ExcavationDataReceiver::disconnect()
{
    m_reconnectTimer->stop();
    m_socket->disconnectFromHost();
}

bool ExcavationDataReceiver::isConnected() const
{
    return m_socket->state() == QAbstractSocket::ConnectedState;
}

void ExcavationDataReceiver::onConnected()
{
    qDebug() << "已连接到设备";
    m_reconnectTimer->stop();
    emit connectionStateChanged(true);
}

void ExcavationDataReceiver::onDisconnected()
{
    qDebug() << "已断开连接";
    emit connectionStateChanged(false);
    
    // 启动自动重连
    if (!m_reconnectTimer->isActive()) {
        m_reconnectTimer->start();
    }
}

void ExcavationDataReceiver::onReadyRead()
{
    // 读取所有可用数据
    m_buffer.append(m_socket->readAll());
    
    // 处理缓冲区中的数据（按行分割）
    int pos;
    while ((pos = m_buffer.indexOf('\n')) != -1) {
        QByteArray line = m_buffer.left(pos);
        m_buffer.remove(0, pos + 1);
        
        if (line.isEmpty()) {
            continue;
        }
        
        // 尝试解析为JSON
        QJsonDocument doc = QJsonDocument::fromJson(line);
        if (!doc.isNull() && doc.isObject()) {
            parseJsonData(line);
        } else {
            // 解析为固定格式
            parseFixedFormatData(QString::fromUtf8(line));
        }
    }
}

void ExcavationDataReceiver::onError(QAbstractSocket::SocketError error)
{
    QString errorStr = m_socket->errorString();
    qWarning() << "网络错误：" << errorStr;
    emit errorOccurred(errorStr);
}

void ExcavationDataReceiver::onReconnectTimeout()
{
    if (!isConnected()) {
        qDebug() << "尝试重新连接...";
        m_socket->connectToHost(m_host, m_port);
    }
}

void ExcavationDataReceiver::parseJsonData(const QByteArray &data)
{
    QJsonDocument doc = QJsonDocument::fromJson(data);
    QJsonObject obj = doc.object();
    
    ExcavationParameter param;
    param.setProjectId(m_projectId);
    param.setExcavationTime(QDateTime::fromString(obj["timestamp"].toString(), "yyyy-MM-dd HH:mm:ss"));
    param.setStakeMark(obj["stake_mark"].toString());
    param.setMileage(obj["mileage"].toDouble());
    param.setExcavationMode(obj["excavation_mode"].toString());
    param.setChamberPressure(obj["chamber_pressure"].toDouble());
    param.setThrustForce(obj["thrust_force"].toDouble());
    param.setCutterSpeed(obj["cutter_speed"].toDouble());
    param.setCutterTorque(obj["cutter_torque"].toDouble());
    param.setExcavationSpeed(obj["excavation_speed"].toDouble());
    param.setGroutingPressure(obj["grouting_pressure"].toDouble());
    param.setGroutingVolume(obj["grouting_volume"].toDouble());
    param.setSegmentNumber(obj["segment_number"].toString());
    param.setExcavationDuration(obj["excavation_duration"].toInt());
    param.setIdleDuration(obj["idle_duration"].toInt());
    param.setFaultDuration(obj["fault_duration"].toInt());
    param.setExcavationDistance(obj["excavation_distance"].toDouble());
    
    // 保存到数据库
    saveToDatabase(param);
    
    // 发送信号通知界面更新
    emit newDataReceived(param);
}

void ExcavationDataReceiver::parseFixedFormatData(const QString &line)
{
    QStringList fields = line.split('|');
    
    if (fields.size() < 16) {
        qWarning() << "数据格式错误，字段数不足";
        return;
    }
    
    ExcavationParameter param;
    param.setProjectId(m_projectId);
    param.setExcavationTime(QDateTime::fromString(fields[0].trimmed(), "yyyy-MM-dd HH:mm:ss"));
    param.setStakeMark(fields[1].trimmed());
    param.setMileage(fields[2].trimmed().toDouble());
    param.setExcavationMode(fields[3].trimmed());
    param.setChamberPressure(fields[4].trimmed().toDouble());
    param.setThrustForce(fields[5].trimmed().toDouble());
    param.setCutterSpeed(fields[6].trimmed().toDouble());
    param.setCutterTorque(fields[7].trimmed().toDouble());
    param.setExcavationSpeed(fields[8].trimmed().toDouble());
    param.setGroutingPressure(fields[9].trimmed().toDouble());
    param.setGroutingVolume(fields[10].trimmed().toDouble());
    param.setSegmentNumber(fields[11].trimmed());
    param.setExcavationDuration(fields[12].trimmed().toInt());
    param.setIdleDuration(fields[13].trimmed().toInt());
    param.setFaultDuration(fields[14].trimmed().toInt());
    param.setExcavationDistance(fields[15].trimmed().toDouble());
    
    // 保存到数据库
    saveToDatabase(param);
    
    // 发送信号通知界面更新
    emit newDataReceived(param);
}

void ExcavationDataReceiver::saveToDatabase(const ExcavationParameter &param)
{
    ExcavationParameterDAO dao;
    if (!dao.insertExcavationParameter(param)) {
        qWarning() << "保存掘进参数到数据库失败：" << dao.getLastError();
    }
}
```

#### 使用方法

在主窗口或项目详情界面中：

```cpp
// 创建接收器
ExcavationDataReceiver *receiver = new ExcavationDataReceiver(this);
receiver->setProjectId(currentProjectId);

// 连接信号
connect(receiver, &ExcavationDataReceiver::newDataReceived, 
        this, [this](const ExcavationParameter &param) {
    // 实时更新界面显示
    updateExcavationDisplay(param);
});

connect(receiver, &ExcavationDataReceiver::connectionStateChanged,
        this, [this](bool connected) {
    if (connected) {
        statusLabel->setText("设备已连接");
        statusLabel->setStyleSheet("color: green;");
    } else {
        statusLabel->setText("设备已断开");
        statusLabel->setStyleSheet("color: red;");
    }
});

// 连接到设备（IP地址和端口根据实际情况修改）
receiver->connectToDevice("192.168.1.100", 8888);
```

---

方案3：串口通信

适用场景
- 盾构设备通过RS232/RS485串口输出数据
- 现场无网络环境

#### 实现代码示例

需要在.pro文件中添加：
```
QT += serialport
```

创建 `SerialDataReceiver.h`：

```cpp
#ifndef SERIALDATARECEIVER_H
#define SERIALDATARECEIVER_H

#include <QObject>
#include <QSerialPort>
#include "src/models/ExcavationParameter.h"

class SerialDataReceiver : public QObject
{
    Q_OBJECT

public:
    explicit SerialDataReceiver(QObject *parent = nullptr);
    ~SerialDataReceiver();
    
    // 打开串口
    bool openPort(const QString &portName, int baudRate = 9600);
    
    // 关闭串口
    void closePort();
    
    // 设置项目ID
    void setProjectId(int projectId) { m_projectId = projectId; }

signals:
    void newDataReceived(const ExcavationParameter &param);
    void errorOccurred(const QString &error);

private slots:
    void onReadyRead();
    void onError(QSerialPort::SerialPortError error);

private:
    void parseData(const QString &line);

private:
    QSerialPort *m_serial;
    int m_projectId;
    QByteArray m_buffer;
};

#endif // SERIALDATARECEIVER_H
```

使用方法类似TCP接口，只需改为：

```cpp
SerialDataReceiver *receiver = new SerialDataReceiver(this);
receiver->setProjectId(currentProjectId);
receiver->openPort("COM3", 9600);  // Windows
// 或
receiver->openPort("/dev/ttyUSB0", 9600);  // Linux
```

---

### 方案4：REST API接口（适用于云平台对接）

#### 适用场景
- 数据存储在云平台或第三方系统
- 需要定期拉取数据

#### 实现代码示例

使用QNetworkAccessManager定期请求API：

```cpp
void ProjectManagementWindow::fetchExcavationDataFromAPI()
{
    QNetworkAccessManager *manager = new QNetworkAccessManager(this);
    
    QString url = QString("https://api.example.com/excavation/latest?project_id=%1")
                      .arg(currentProjectId);
    
    QNetworkRequest request(url);
    request.setHeader(QNetworkRequest::ContentTypeHeader, "application/json");
    // 如需要认证
    request.setRawHeader("Authorization", "Bearer YOUR_TOKEN");
    
    QNetworkReply *reply = manager->get(request);
    
    connect(reply, &QNetworkReply::finished, this, [this, reply]() {
        if (reply->error() == QNetworkReply::NoError) {
            QByteArray response = reply->readAll();
            QJsonDocument doc = QJsonDocument::fromJson(response);
            QJsonArray array = doc.array();
            
            QList<ExcavationParameter> params;
            for (const QJsonValue &value : array) {
                QJsonObject obj = value.toObject();
                
                ExcavationParameter param;
                param.setProjectId(currentProjectId);
                // ... 解析JSON字段
                
                params.append(param);
            }
            
            // 批量保存
            ExcavationParameterDAO dao;
            dao.batchInsertExcavationParameters(params);
            
            // 刷新界面
            loadExcavationData();
        } else {
            qWarning() << "API请求失败：" << reply->errorString();
        }
        
        reply->deleteLater();
    });
}

// 设置定时器定期拉取
QTimer *fetchTimer = new QTimer(this);
connect(fetchTimer, &QTimer::timeout, this, &ProjectManagementWindow::fetchExcavationDataFromAPI);
fetchTimer->start(60000);  // 每60秒拉取一次
```

---

## 三、数据接口汇总

### 3.1 核心API（已实现）

所有数据接口都在 `ExcavationParameterDAO` 类中，位于 `src/database/ExcavationParameterDAO.h/cpp`

```cpp
// 1. 插入单条记录
bool insertExcavationParameter(const ExcavationParameter &param);

// 2. 批量插入记录（推荐用于导入）
bool batchInsertExcavationParameters(const QList<ExcavationParameter> &params);

// 3. 查询项目所有记录
QList<ExcavationParameter> getExcavationParametersByProjectId(int projectId);

// 4. 按时间范围查询
QList<ExcavationParameter> getExcavationParametersByTimeRange(
    int projectId, 
    const QDateTime &startTime, 
    const QDateTime &endTime);

// 5. 获取最新记录
bool getLatestExcavationParameter(int projectId, ExcavationParameter &param);

// 6. 分页查询
QList<ExcavationParameter> getExcavationParametersByPage(
    int projectId, 
    int page, 
    int pageSize);
```

### 3.2 使用示例

```cpp
#include "src/database/ExcavationParameterDAO.h"
#include "src/models/ExcavationParameter.h"

// 创建DAO对象
ExcavationParameterDAO dao;

// 示例1：插入单条数据
ExcavationParameter param;
param.setProjectId(1);
param.setExcavationTime(QDateTime::currentDateTime());
param.setStakeMark("K3+087.00");
param.setMileage(3087.00);
param.setExcavationMode("土压平衡");
param.setChamberPressure(0.28);
param.setThrustForce(2600.0);
param.setCutterSpeed(1.5);
param.setCutterTorque(2150.0);
param.setExcavationSpeed(50.0);
param.setGroutingPressure(2.5);
param.setGroutingVolume(6.0);
param.setSegmentNumber("SG-3010");
param.setExcavationDuration(5);
param.setIdleDuration(0);
param.setFaultDuration(0);
param.setExcavationDistance(0.05);

if (dao.insertExcavationParameter(param)) {
    qDebug() << "数据插入成功";
} else {
    qWarning() << "插入失败：" << dao.getLastError();
}

// 示例2：获取最新数据
ExcavationParameter latest;
if (dao.getLatestExcavationParameter(1, latest)) {
    qDebug() << "最新桩号：" << latest.getStakeMark();
    qDebug() << "土压力：" << latest.getChamberPressure() << "MPa";
}

// 示例3：查询某个时间段的数据
QDateTime start = QDateTime::fromString("2024-12-03 09:00:00", "yyyy-MM-dd HH:mm:ss");
QDateTime end = QDateTime::fromString("2024-12-03 12:00:00", "yyyy-MM-dd HH:mm:ss");
QList<ExcavationParameter> records = dao.getExcavationParametersByTimeRange(1, start, end);
qDebug() << "查询到" << records.size() << "条记录";
```

---

四、界面自动更新机制

### 4.1 定时器刷新（简单方案）

```cpp
// 在项目详情界面
QTimer *refreshTimer = new QTimer(this);
connect(refreshTimer, &QTimer::timeout, this, [this]() {
    loadExcavationParams();  // 重新加载数据
});
refreshTimer->start(5000);  // 每5秒刷新一次
```

### 4.2 数据库监听（高级方案）

使用Qt的信号槽机制，在数据插入时立即通知界面：

```cpp
// 在ExcavationParameterDAO中添加信号
signals:
    void dataInserted(int projectId);

// 在insertExcavationParameter方法成功后发射信号
emit dataInserted(param.getProjectId());

// 在界面中连接信号
connect(&dao, &ExcavationParameterDAO::dataInserted, 
        this, [this](int projectId) {
    if (projectId == currentProjectId) {
        loadExcavationParams();  // 自动刷新
    }
});
```

---

五、测试与验证

5.1 清除示例数据

在投入生产前，建议清除数据库中的示例数据：

```cpp
方法1：删除整个数据库文件
位置：应用程序目录/data/shield_platform.db
删除后重启程序会自动创建新的空数据库（但会重新生成示例数据）

方法2：只删除掘进参数表的数据（推荐）
ExcavationParameterDAO dao;
dao.deleteExcavationParametersByProjectId(1);  // 删除项目ID为1的所有记录
```

### 5.2 测试CSV导入

1. 准备测试CSV文件
2. 在项目管理界面点击"导入CSV"
3. 选择CSV文件
4. 检查导入结果
5. 在项目详情界面查看数据是否正确显示

### 5.3 测试网络接口

1. 运行设备模拟器（发送测试数据）
2. 启动Qt程序，连接到模拟器
3. 观察界面是否实时更新
4. 检查数据库是否正确保存

---

六、技术支持

6.1 常见问题

Q1：数据写入数据库后，界面没有自动更新？**

A：需要手动调用刷新方法或实现自动刷新机制（见第四章）

Q2：CSV导入时出现乱码？**

A：确保CSV文件使用UTF-8编码保存

Q3：网络连接经常断开？**

A：已实现自动重连机制（每5秒重试），检查网络稳定性和设备IP地址配置

Q4：不同项目的数据会混淆吗？**

A：不会。数据库通过`project_id`字段区分不同项目，插入数据时必须指定正确的项目ID

6.2 性能优化建议

1. **批量导入**：使用`batchInsertExcavationParameters()`而非循环调用`insertExcavationParameter()`
2. **索引优化**：已对`project_id`和`excavation_time`字段建立索引
3. **数据归档**：定期将老旧数据导出并从数据库删除，避免表过大
4. **界面更新频率**：不建议低于2秒，避免界面卡顿

## 附录：参数字段说明

| 字段名 | 数据类型 | 单位 | 说明 | 示例值 |
|-------|---------|------|------|--------|
| excavation_time | DateTime | - | 掘进时间 | 2024-12-03 10:00:00 |
| stake_mark | String | - | 桩号 | K3+086.50 |
| mileage | Double | 米 | 累计里程 | 3086.50 |
| excavation_mode | String | - | 掘进模式 | 土压平衡 |
| chamber_pressure | Double | MPa | 土仓土压力 | 0.28 |
| thrust_force | Double | kN | 千斤顶推力 | 2600.0 |
| cutter_speed | Double | rpm | 刀盘转速 | 1.5 |
| cutter_torque | Double | kN·m | 刀盘扭矩 | 2150.0 |
| excavation_speed | Double | mm/min | 掘进速度 | 50.0 |
| grouting_pressure | Double | MPa | 注浆压力 | 2.5 |
| grouting_volume | Double | m³ | 注浆量 | 6.0 |
| segment_number | String | - | 管片编号 | SG-3010 |
| excavation_duration | Integer | 分钟 | 掘进时长 | 5 |
| idle_duration | Integer | 分钟 | 闲置时长 | 0 |
| fault_duration | Integer | 分钟 | 故障时长 | 0 |
| excavation_distance | Double | 米 | 单次掘进距离 | 0.05 |

---

**文档版本：** v1.0  
**最后更新：** 2024-12-03  
**适用系统：** 盾构地质可视化平台 Qt 6.5.3
